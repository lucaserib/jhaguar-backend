// üî• CRITICAL PERFORMANCE FIX for completeRideNew method
// This is the optimized version to replace the current implementation

async completeRideNew(
  driverId: string,
  rideId: string,
  completeData: CompleteRideDto,
) {
  try {
    // üî• STEP 1: Ultra-light atomic ride completion (fastest possible transaction)
    const ride = await this.prisma.ride.update({
      where: {
        id: rideId,
        driverId,
        status: RideStatus.IN_PROGRESS, // This acts as the lock condition
      },
      data: {
        status: RideStatus.COMPLETED,
        dropOffTime: completeData.completedAt,
        actualDistance: completeData.actualDistance,
        actualDuration: completeData.actualDuration,
      },
      include: {
        passenger: { select: { id: true, user: { select: { id: true } } } },
        driver: { select: { id: true, user: { select: { id: true } } } },
        payment: true,
      },
    });

    const driverEarnings = (ride.finalPrice || 0) * 0.9;

    // üî• STEP 2: Non-blocking async updates (fire and forget for non-critical operations)
    const statsUpdatePromises = [
      // Update driver stats
      this.prisma.driver.update({
        where: { id: driverId },
        data: {
          isAvailable: true,
          isActiveTrip: false,
          totalRides: { increment: 1 },
        },
      }).catch(error => this.logger.warn(`Error updating driver stats:`, error)),

      // Update passenger stats
      this.prisma.passenger.update({
        where: { id: ride.passengerId },
        data: {
          totalRides: { increment: 1 },
        },
      }).catch(error => this.logger.warn(`Error updating passenger stats:`, error)),

      // Create status history
      this.createRideStatusHistory(
        rideId,
        driverId,
        'IN_PROGRESS',
        'COMPLETED',
        {
          latitude: completeData.finalLocation.latitude,
          longitude: completeData.finalLocation.longitude,
        },
      ).catch(error => this.logger.warn(`Error creating ride history:`, error)),
    ];

    // üî• STEP 3: Process payment synchronously (critical for completion)
    let paymentResult: { success: boolean; data: any; message: string } | null = null;

    if (ride.payment?.method) {
      this.logger.log(`üí∞ Processing ${ride.payment.method} payment for ride ${rideId}: R$ ${ride.finalPrice}`);

      try {
        // Process payment with faster method call
        paymentResult = await this.paymentsService.processRidePaymentByMethod(
          ride.payment.method,
          rideId,
          ride.passenger.user.id, // passengerId
          (ride.driver?.user.id || ride.driverId) as string, // driverId
          ride.finalPrice || 0,
          `Corrida ${rideId.substring(0, 8)}`,
        );

        if (!paymentResult.success) {
          this.logger.error(`‚ùå Payment failed for ride ${rideId}: ${paymentResult.message}`);
          // ROLLBACK: Revert ride status if payment fails
          await this.prisma.ride.update({
            where: { id: rideId },
            data: { status: RideStatus.IN_PROGRESS }
          });
          throw new BadRequestException(`Falha no pagamento: ${paymentResult.message}`);
        }

        // Update payment status (fast single operation)
        await this.prisma.payment.update({
          where: { id: ride.payment.id },
          data: {
            status: PaymentStatus.PAID,
            confirmedByDriver: true,
            driverConfirmationTime: new Date(),
            driverNotes: `Automatic payment processing - ${ride.payment.method}`,
          },
        });

        this.logger.log(`‚úÖ ${ride.payment.method} payment processed successfully: R$ ${ride.finalPrice} for ride ${rideId}`);
      } catch (paymentError) {
        this.logger.error(`üí• Critical payment error for ride ${rideId}:`, paymentError);
        // ROLLBACK: Revert ride status if payment fails
        await this.prisma.ride.update({
          where: { id: rideId },
          data: { status: RideStatus.IN_PROGRESS }
        });
        throw new BadRequestException(`Falha cr√≠tica no pagamento: ${paymentError instanceof Error ? paymentError.message : 'Erro desconhecido'}`);
      }
    }

    // üî• STEP 4: Send WebSocket notifications (fast, non-blocking)
    if (this.rideGateway) {
      // Fire and forget WebSocket notifications
      setImmediate(() => {
        try {
          this.rideGateway.emitStatusUpdate(rideId, 'completed', {
            latitude: completeData.finalLocation.latitude,
            longitude: completeData.finalLocation.longitude,
          });

          this.rideGateway.emitRideCompleted(rideId, {
            distance: completeData.actualDistance,
            duration: completeData.actualDuration,
            finalLocation: completeData.finalLocation,
            finalPrice: ride.finalPrice,
            earnings: driverEarnings,
            paymentProcessed: paymentResult?.success || false,
          });

          this.logger.log(`‚úÖ WebSocket notifications sent: ride completed for ${rideId}`);
        } catch (error) {
          this.logger.warn(`Error sending WebSocket notifications:`, error);
        }
      });
    }

    // Wait for all non-critical operations to complete (but don't block the response)
    Promise.all(statsUpdatePromises).then(() => {
      this.logger.log(`‚úÖ All stats updated for ride ${rideId}`);
    }).catch(error => {
      this.logger.warn(`Some stats updates failed for ride ${rideId}:`, error);
    });

    this.logger.log(
      `üèÅ Ride ${rideId} completed ULTRA-FAST by driver ${driverId}. Earnings: ${driverEarnings}, Payment: ${paymentResult?.success ? 'SUCCESS' : 'N/A'}`,
    );

    return {
      success: true,
      data: {
        status: 'completed',
        rideId,
        finalPrice: ride.finalPrice,
        earnings: driverEarnings,
        paymentProcessed: paymentResult?.success || false,
        completedAt: completeData.completedAt,
      },
      message: 'Corrida finalizada com sucesso',
    };

  } catch (error) {
    this.logger.error(`Error completing ride ${rideId}:`, error);
    return {
      success: false,
      data: null,
      message: error instanceof Error ? error.message : 'Erro ao finalizar corrida',
    };
  }
}